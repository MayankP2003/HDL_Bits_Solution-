4-bit shift register
module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q); 
    
    always @(posedge clk or posedge areset) begin
        if (areset) q <= 0;
        else if (load) q <= data;
        else if (ena) q <= {1'b0,q[3:1]};
        else q <= q;
    end
endmodule

Left/Right rotator
module top_module(
    input clk,
    input load,
    input [1:0] ena,
    input [99:0] data,
    output reg [99:0] q); 
    always @(posedge clk) begin
        if (load) q <= data;
        else begin
            case (ena)
                2'b00:q <= q;
                2'b01:q <= {q[0],q[99:1]};
                2'b10:q <= {q[98:0],q[99]};
                2'b11:q <= q;
             endcase
        end
    end
endmodule

Left/right arithmetic shift by 1 or 8
module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);
    
    always @(posedge clk) begin
        if (load) q <= data;
        else if(ena) begin
            case (amount)
                2'b00:q <= {q[62:0],1'b0};
                2'b01:q <= {q[55:0],8'b0};
                2'b10: q <= {q[63],q[63:1]}; 
                2'b11:q <= {{8{q[63]}},q[63:8]};
                default: q <= q;
            endcase
        end
        else q <= q;  
    end
endmodule


5-bit LFSR
module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 5'h1
    output [4:0] q
); 
wire w1,w2;
    assign w1 = q[0];
    assign w2 = q[3]^q[0];
    
    always @(posedge clk) begin
        if(reset) q <= 1;
        else q <= {w1,q[4],w2,q[2:1]};
    end
endmodule

3-bit LFSR
module top_module (
	input [2:0] SW,      // R
	input [1:0] KEY,     // L and clk
	output [2:0] LEDR);  // Q
wire w1,w2,w3,w4;
    assign w1 = (KEY[1])?SW[0]:LEDR[2];
    assign w2 = (KEY[1])?SW[1]:LEDR[0];
    assign w3 = LEDR[1]^LEDR[2];
    assign w4 = (KEY[1])?SW[2]:w3;
    always @(posedge KEY[0]) begin
        LEDR <= {w4,w2,w1};
    end
endmodule

32-bit LFSR
module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
wire w1,w2,w3,w4;
    assign w1 = q[0];
    assign w2 = q[22]^q[0];
    assign w3 = q[2]^q[0];
    assign w4 = q[1]^q[0];
    
always @(posedge clk) begin
        if (reset) q <=1;
    else begin q[31] <= w1;
        q[30:22] <= q[31:23];
        q[21] <= w2;
        q[20:2] <= q[21:3];
        q[1] <= w3;
        q[0] <= w4;
    end
end
        
endmodule


shift register 1
module top_module (
    input clk,
    input resetn,   // synchronous reset
    input in,
    output out);
    reg [2:0] q;
    d_ff (clk,in,q[2],resetn);
    d_ff (clk,q[2],q[1],resetn);
    d_ff (clk,q[1],q[0],resetn);
    d_ff (clk,q[0],out,resetn);
    
endmodule
module d_ff(clk,d,q,rst);
    input clk,d,rst;
    output q;
    always @(posedge clk) begin
        if (!rst) q<=0;
        else q<=d;
    end
endmodule

Shift register 2
module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); 
    MUXDFF G1(KEY[0],KEY[3],SW[3],KEY[1],KEY[2],LEDR[3]);
    MUXDFF G2(KEY[0],LEDR[3],SW[2],KEY[1],KEY[2],LEDR[2]);
    MUXDFF G3(KEY[0],LEDR[2],SW[1],KEY[1],KEY[2],LEDR[1]);
    MUXDFF G4(KEY[0],LEDR[1],SW[0],KEY[1],KEY[2],LEDR[0]);
endmodule

module MUXDFF (clk,w,R,E,L,Q);
input clk;
input w, R, E, L;
output Q;

wire w1,w2;
    assign w1 = (E)?w:Q;
    assign w2 = (L)?R:w1;
    always @(posedge clk) begin
      Q <= w2;  
    end

endmodule


3-Input LUT
module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output reg Z ); 
    reg [7:0] Q;
   initial Q<= 0;
    always @(posedge clk) begin
        if(enable) begin Q[7:0]<={Q[6:0],S}; end
        else Q <= Q; end
    always @(*) begin
        case ({A,B,C}) 
            3'b000:Z = Q[0];
            3'b001:Z = Q[1];
            3'b010:Z = Q[2];
            3'b011:Z = Q[3];
            3'b100:Z = Q[4];
            3'b101:Z = Q[5];
            3'b110:Z = Q[6];
            3'b111:Z = Q[7];
            default: Z = Q[0];
        endcase
    end
endmodule
